# 数据同步策略深度分析

## 核心问题

**前端用户操作时，应该何时写入飞书？**

---

## 方案A：前端创建时立即写入飞书

### 流程图

```
前端用户提交
    ↓
创建本地任务（status = PENDING）
    ↓
【立即】在飞书创建记录（status = Pending）
    ↓
保存 feishuRecordId
    ↓
触发N8N工作流
    ↓
N8N处理中...（飞书记录保持 Pending）
    ↓
N8N回调 → 更新本地任务 → 更新飞书记录（status = Completed/Failed）
```

### 优点

1. **数据可见性**
   - ✅ 飞书用户立即看到新任务
   - ✅ 任务状态可追踪（Pending → Processing → Completed）
   - ✅ 便于飞书用户监控进度

2. **数据完整性**
   - ✅ 所有任务都在飞书有记录
   - ✅ 即使N8N失败，飞书也有任务历史
   - ✅ 便于后续排查问题

3. **双向关联**
   - ✅ 前端任务和飞书记录立即关联
   - ✅ 可以通过 feishuRecordId 反向查询
   - ✅ 飞书用户可以直接操作记录

### 缺点

1. **额外延迟**
   - ❌ 前端创建任务需要等待飞书API响应
   - ❌ 如果飞书服务慢，影响用户体验
   - ❌ 需要处理飞书API失败的情况

2. **数据冗余**
   - ❌ 飞书存储了大量"处理中"的临时数据
   - ❌ 需要定期清理失败的任务记录

3. **复杂性增加**
   - ❌ 需要处理飞书创建失败的场景
   - ❌ 需要断路器保护
   - ❌ 需要降级策略

### N8N工作流影响

**影响程度：小**

- N8N工作流不需要改动
- N8N回调时更新飞书记录即可
- 输入参数包含 feishuRecordId

### 飞书表格影响

**影响程度：中等**

- 新增字段：
  - `数据来源`（前端/飞书/API）
  - `同步状态`（已同步/同步中/冲突）
  - `前端用户ID`（可选，用于区分）
- 现有字段可以复用

---

## 方案B：N8N处理完成后写入飞书

### 流程图

```
前端用户提交
    ↓
创建本地任务（status = PENDING）
    ↓
触发N8N工作流
    ↓
N8N处理中...（飞书无记录）
    ↓
N8N回调 → 更新本地任务（status = Completed）
    ↓
【首次】在飞书创建记录（status = Completed）
    ↓
保存 feishuRecordId
```

### 优点

1. **性能优先**
   - ✅ 前端创建任务快速返回
   - ✅ 不依赖飞书API响应时间
   - ✅ 用户体验更好

2. **数据精简**
   - ✅ 飞书只存储成功的任务
   - ✅ 减少无效数据
   - ✅ 数据质量更高

3. **实现简单**
   - ✅ 不需要处理飞书创建失败
   - ✅ 不需要断路器保护
   - ✅ 代码更简单

### 缺点

1. **数据可见性差**
   - ❌ 飞书用户看不到处理中的任务
   - ❌ 无法追踪任务进度
   - ❌ 任务"黑洞"期（提交到完成之间飞书无记录）

2. **排查困难**
   - ❌ 如果N8N失败，飞书完全无记录
   - ❌ 无法在飞书看到失败的任务
   - ❌ 问题时排查困难

3. **双向关联延迟**
   - ❌ 前端任务和飞书记录不能立即关联
   - ❌ 需要等待N8N完成才能关联

### N8N工作流影响

**影响程度：中等**

- N8N工作流需要增加飞书创建逻辑
- 或者N8N回调后由后端创建飞书记录
- 增加了N8N工作流的复杂度

### 飞书表格影响

**影响程度：小**

- 字段基本不需要改动
- 只是飞书记录创建时机不同

---

## 方案C：混合方案（推荐）

### 流程图

```
前端用户提交
    ↓
创建本地任务（status = PENDING）
    ↓
【异步】在飞书创建记录（不阻塞主流程）
    ↓
触发N8N工作流
    ↓
N8N处理中...（飞书记录显示 "处理中"）
    ↓
N8N回调 → 更新本地任务 → 更新飞书记录
```

### 核心设计

1. **前端创建任务**
   - 立即返回成功（不等待飞书）
   - 异步触发飞书记录创建
   - 如果飞书创建失败，记录失败但不阻塞

2. **飞书记录创建**
   - 通过事件系统异步处理
   - 使用断路器保护
   - 失败时标记任务状态

3. **状态同步**
   - N8N回调时更新飞书记录
   - 如果飞书记录不存在，创建新记录
   - 确保最终一致性

---

## 飞书字段设计（最小改动）

### 必需字段

| 字段名     | 类型     | 说明                                | 是否新增 |
| ---------- | -------- | ----------------------------------- | -------- |
| 提示词     | 文本     | 用户输入                            | 复用     |
| 状态       | 单选     | Pending/Processing/Completed/Failed | 复用     |
| 创建时间   | 日期时间 | 任务创建时间                        | 复用     |
| 数据来源   | 单选     | 前端/飞书/API                       | ✅ 新增  |
| 前端用户ID | 文本     | 前端用户标识                        | ✅ 新增  |

### 数据来源字段

```
选项1：前端用户
- 图标：🌐
- 说明：通过Web前端提交的任务

选项2：飞书用户
- 图标：📊
- 说明：通过飞书多维表格提交的任务

选项3：API自动
- 图标：🤖
- 说明：通过API或N8N自动创建的任务
```

### 前端用户ID字段

```
用途：区分不同的前端用户

取值：
- "default-user"：默认用户（当前系统）
- "user_abc123"：具体用户ID（如果未来支持多用户）

显示格式：
- 前端用户 #abc123
- 或者：Web用户
```

---

## 反向验证

### 验证1：飞书用户编辑前端创建的任务

**场景**：前端用户创建任务 → 飞书用户修改提示词 → 冲突？

```
方案A（立即写入飞书）：
✅ 飞书用户可以看到任务
✅ 飞书用户可以修改提示词
⚠️ 需要冲突解决机制

方案B（完成后写入）：
❌ 飞书用户看不到处理中的任务
❌ 无法在任务生成前干预
✅ 无冲突（因为看不到）
```

**结论**：如果需要飞书用户能够干预前端任务，必须选方案A

### 验证2：N8N失败时的数据追溯

**场景**：前端用户提交 → N8N失败 → 飞书有记录吗？

```
方案A（立即写入飞书）：
✅ 飞书有记录，状态为 Failed
✅ 可以看到错误信息
✅ 便于重试

方案B（完成后写入）：
❌ 飞书完全无记录
❌ 无法追溯失败的任务
❌ "黑洞"任务
```

**结论**：如果需要在飞书追溯所有任务（包括失败的），必须选方案A

### 验证3：性能影响

**场景**：100个前端用户同时提交任务

```
方案A（立即写入飞书）：
⏱️ 前端响应时间：~500ms（等待飞书API）
⚠️ 飞书API压力：100次并发请求
✅ 数据完整性：100%记录

方案B（完成后写入）：
⏱️ 前端响应时间：~50ms（仅本地DB）
✅ 飞书API压力：分散到N8N完成后
⚠️ 数据完整性：只有成功任务有记录
```

**结论**：如果性能优先且只关心成功任务，可选方案B

---

## 最终推荐：方案A（立即写入飞书）+ 优化

### 推荐理由

1. **符合"双轨工作流"设计理念**
   - 轨道A（前端）和轨道B（飞书）数据互通
   - 飞书是"主要数据源"
   - 所有任务都应该在飞书有记录

2. **便于飞书用户操作**
   - 可以看到所有任务（包括处理中的）
   - 可以修改前端创建的任务
   - 可以在任务生成前干预

3. **便于问题排查**
   - 所有任务都有飞书记录
   - 可以看到失败的任务
   - 便于后续重试

### 优化措施

1. **异步处理**

   ```typescript
   // 前端创建任务
   async createTask(params) {
     // 1. 快速创建本地任务
     const task = await taskRepo.create(params);

     // 2. 立即返回（不等待飞书）
     emit('task.created', task);

     // 3. 异步创建飞书记录（不阻塞）
     createFeishuRecordAsync(task).catch(err => {
       console.error('飞书同步失败:', err);
       // 标记任务需要同步
       taskRepo.update(task.id, { needsFeishuSync: true });
     });

     return task;
   }
   ```

2. **降级策略**
   - 飞书API失败时不阻塞主流程
   - 标记任务为"需要同步"
   - 后台定时重试

3. **断路器保护**
   - 飞书API连续失败时跳过
   - 避免影响前端性能

---

## N8N工作流最小改动方案

### 现有N8N工作流（不需要改动）

```json
{
  "nodes": [
    {
      "name": "Webhook触发",
      "type": "webhook",
      "parameters": {
        "path": "ai-clothing-generation",
        "responseMode": "responseNode"
      }
    },
    {
      "name": "调用生图API",
      "type": "httpRequest",
      "parameters": {
        "url": "={{$json.apiUrl}}",
        "method": "POST"
      }
    },
    {
      "name": "回调前端",
      "type": "httpRequest",
      "parameters": {
        "url": "={{$json.callbackUrl}}",
        "method": "POST"
      }
    }
  ]
}
```

### 输入参数（已支持）

```json
{
  "taskId": "xxx",
  "userId": "xxx",
  "productImageUrl": "...",
  "prompt": "...",
  "feishuRecordId": "xxx", // 已有，如果前端创建了飞书记录
  "callbackUrl": "..."
}
```

### 输出参数（已支持）

```json
{
  "taskId": "xxx",
  "status": "completed",
  "resultImageUrls": [...],
  "resultImageTokens": [...]
}
```

**结论**：N8N工作流**不需要任何改动**，只需要确保传递 `feishuRecordId`

---

## 飞书表格最小改动方案

### 新增字段（仅2个）

| 字段名   | 类型 | 选项                            | 默认值   |
| -------- | ---- | ------------------------------- | -------- |
| 数据来源 | 单选 | 🌐前端/📊飞书/🤖API             | 🌐前端   |
| 同步状态 | 单选 | ✅已同步/🔄同步中/⚠️冲突/❌失败 | ✅已同步 |

### 字段配置

```javascript
// "数据来源"字段
{
  "field_name": "数据来源",
  "type": "select",
  "options": [
    { "name": "🌐 前端用户", "value": "frontend" },
    { "name": "📊 飞书用户", "value": "feishu" },
    { "name": "🤖 API自动", "value": "api" }
  ],
  "default_value": "frontend"
}

// "同步状态"字段
{
  "field_name": "同步状态",
  "type": "select",
  "options": [
    { "name": "✅ 已同步", "value": "synced" },
    { "name": "🔄 同步中", "value": "syncing" },
    { "name": "⚠️ 冲突", "value": "conflict" },
    { "name": "❌ 失败", "value": "failed" }
  ],
  "default_value": "synced"
}
```

### 条件格式（可选）

```javascript
// 高亮"同步中"的记录
{
  "condition": { "数据来源": "🌐 前端用户", "同步状态": "🔄 同步中" },
  "format": { "background_color": "#DBEAFE" }
}

// 高亮"冲突"的记录
{
  "condition": { "同步状态": "⚠️ 冲突" },
  "format": { "background_color": "#FEE2E2" }
}
```

---

## 总结

### 推荐方案：**方案A（立即写入飞书）**

| 方面     | 说明                                |
| -------- | ----------------------------------- |
| 数据同步 | 前端创建任务时立即在飞书创建记录    |
| 性能优化 | 异步处理，不阻塞主流程              |
| 降级策略 | 飞书失败时标记，后台重试            |
| N8N改动  | **零改动**，只需传递 feishuRecordId |
| 飞书改动 | **最小改动**，仅新增2个字段         |

### 核心原则

1. **数据完整性优先**：所有任务都在飞书有记录
2. **用户体验优先**：异步处理，不阻塞前端
3. **最小改动原则**：尽量减少对N8N和飞书的改动
4. **最终一致性**：允许短暂不一致，通过同步恢复

### 实施建议

**阶段1**（必须）：

- 前端创建任务时异步创建飞书记录
- 新增"数据来源"和"同步状态"字段

**阶段2**（推荐）：

- 添加断路器保护
- 添加降级策略

**阶段3**（可选）：

- 添加冲突检测
- 添加实时状态同步
