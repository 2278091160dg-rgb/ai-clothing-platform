# 多用户并发冲突处理方案

## 方案选择：乐观锁 + 最终一致性

### 核心设计原则

1. **主数据源**：以数据库为最终真相源
2. **乐观锁**：使用版本号检测冲突
3. **最终一致性**：允许短暂不一致，通过同步机制恢复
4. **时间戳优先**：后写入的数据覆盖先写入的（带冲突提示）

---

## 1. 数据库设计优化

### 1.1 添加并发控制字段

```prisma
model Task {
  id                String        @id @default(uuid())

  // 现有字段...
  feishuRecordId    String?       @unique
  prompt            String?
  status            TaskStatus    @default(PENDING)

  // 新增并发控制字段
  version           Int           @default(0)      // 乐观锁版本号
  lastModifiedBy    String?                        // 最后修改者来源
  lastModifiedAt    DateTime      @default(now())  // 最后修改时间
  conflictDetected  Boolean       @default(false)  // 冲突标记

  // 提示词历史
  originalPrompt    String?                        // 原始提示词
  optimizedPrompt   String?                        // 优化后提示词
  promptSource      PromptSource  @default(USER)   // 提示词来源

  @@index([version])
  @@index([lastModifiedAt])
}

enum PromptSource {
  USER           // 用户直接输入
  AI_OPTIMIZED   // AI优化后
  FEISHU         // 飞书表格输入
}
```

---

## 2. 乐观锁实现

### 2.1 更新TaskRepository

```typescript
// src/lib/repositories/task.repository.ts

/**
 * 带版本检查的更新（乐观锁）
 */
async updateWithVersion(
  taskId: string,
  updates: UpdateTaskInput,
  expectedVersion: number
): Promise<Task> {
  const current = await this.findById(taskId);

  if (!current) {
    throw new Error('Task not found');
  }

  if (current.version !== expectedVersion) {
    // 版本冲突
    const conflict = await this.detectConflict(taskId, current, updates);

    throw new VersionConflictError({
      taskId,
      currentVersion: current.version,
      expectedVersion,
      actualData: current,
      conflict,
    });
  }

  // 更新并递增版本号
  const updated = await this.prisma.task.update({
    where: { id: taskId },
    data: {
      ...updates,
      version: { increment: 1 },
      lastModifiedAt: new Date(),
      lastModifiedBy: this.determineSource(),
    },
  });

  return updated;
}

/**
 * 冲突检测
 */
private async detectConflict(
  taskId: string,
  current: Task,
  updates: UpdateTaskInput
): Promise<ConflictInfo> {
  const conflicts: string[] = [];

  // 检查关键字段是否被修改
  if (updates.prompt && updates.prompt !== current.prompt) {
    conflicts.push('prompt');
  }

  if (updates.status && updates.status !== current.status) {
    conflicts.push('status');
  }

  // 检查飞书侧是否更新
  if (current.feishuRecordId) {
    const feishuService = getFeishuService();
    try {
      const feishuRecord = await feishuService.getRecord(current.feishuRecordId);
      const feishuModified = new Date(feishuRecord.last_modified_time);

      // 如果飞书记录更新时间晚于本地记录
      if (feishuModified > current.lastModifiedAt) {
        conflicts.push('feishu_data');
      }
    } catch {
      // 飞书记录不可访问，忽略
    }
  }

  return {
    taskId,
    conflicts,
    localVersion: current.version,
    lastModifiedBy: current.lastModifiedBy,
    lastModifiedAt: current.lastModifiedAt,
  };
}

/**
 * 确定数据来源
 */
private determineSource(): string {
  // 根据调用上下文判断是Web还是飞书
  return 'web'; // 或 'feishu', 'api'
}

/**
 * 版本冲突错误
 */
export class VersionConflictError extends Error {
  public readonly conflict: ConflictInfo;

  constructor(details: {
    taskId: string;
    currentVersion: number;
    expectedVersion: number;
    actualData: Task;
    conflict: ConflictInfo;
  }) {
    super(`Version conflict for task ${details.taskId}`);
    this.name = 'VersionConflictError';
    this.conflict = details.conflict;
  }
}
```

---

## 3. 前端冲突处理

### 3.1 乐观锁UI组件

```typescript
// src/components/ConflictResolutionDialog.tsx

interface ConflictResolutionDialogProps {
  conflict: ConflictInfo;
  onResolve: (resolution: 'use_local' | 'use_remote' | 'merge') => void;
}

export function ConflictResolutionDialog({
  conflict,
  onResolve,
}: ConflictResolutionDialogProps) {
  return (
    <Dialog open>
      <DialogContent>
        <DialogTitle>数据冲突检测</DialogTitle>

        <div className="space-y-4">
          <Alert>
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>
              检测到此任务已被其他用户修改，请选择处理方式：
            </AlertDescription>
          </Alert>

          {/* 冲突字段详情 */}
          <div className="text-sm text-muted-foreground">
            <p>最后修改者：{conflict.lastModifiedBy}</p>
            <p>修改时间：{new Date(conflict.lastModifiedAt).toLocaleString()}</p>
            <p>冲突字段：{conflict.conflicts.join(', ')}</p>
          </div>

          {/* 解决方案选项 */}
          <div className="flex gap-2">
            <Button onClick={() => onResolve('use_local')}>
              使用我的修改
            </Button>
            <Button onClick={() => onResolve('use_remote')} variant="outline">
              使用对方修改
            </Button>
            <Button onClick={() => onResolve('merge')} variant="secondary">
              查看详情后决定
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

### 3.2 任务卡片显示修改者

```typescript
// src/components/TaskCard.tsx

interface TaskCardProps {
  task: Task;
  onRefresh: () => void;
}

export function TaskCard({ task, onRefresh }: TaskCardProps) {
  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle>任务 {task.id.slice(0, 8)}</CardTitle>

          {/* 显示最后修改者 */}
          <div className="flex items-center gap-2 text-sm text-muted-foreground">
            <User className="h-4 w-4" />
            <span>{getLastModifiedByLabel(task.lastModifiedBy)}</span>
            <Clock className="h-4 w-4" />
            <span>{formatRelativeTime(task.lastModifiedAt)}</span>

            {/* 实时同步指示器 */}
            <SyncStatusIndicator taskId={task.id} />
          </div>
        </div>
      </CardHeader>

      <CardContent>
        {/* 任务内容 */}
      </CardContent>
    </Card>
  );
}

/**
 * 同步状态指示器
 */
function SyncStatusIndicator({ taskId }: { taskId: string }) {
  const [syncStatus, setSyncStatus] = useState<'synced' | 'syncing' | 'conflict'>('synced');

  useEffect(() => {
    // 监听任务更新事件
    const eventBus = getEventBus();
    const unsubscribe = eventBus.on('task.updated', (data) => {
      if (data.taskId === taskId) {
        setSyncStatus('syncing');
        setTimeout(() => setSyncStatus('synced'), 1000);
      }
    });

    return unsubscribe;
  }, [taskId]);

  return (
    <div className={cn(
      'flex items-center gap-1',
      syncStatus === 'syncing' && 'animate-pulse'
    )}>
      {syncStatus === 'synced' && (
        <CheckCircle className="h-4 w-4 text-green-500" />
      )}
      {syncStatus === 'syncing' && (
        <RefreshCw className="h-4 w-4 text-blue-500 animate-spin" />
      )}
      {syncStatus === 'conflict' && (
        <AlertTriangle className="h-4 w-4 text-yellow-500" />
      )}
    </div>
  );
}
```

---

## 4. 飞书表格设计

### 4.1 添加控制字段

在飞书多维表格中添加以下字段：

| 字段名 | 类型 | 说明 | 是否可编辑 |
|--------|------|------|-----------|
| 版本号 | 数字 | 计算字段，显示当前版本 | 只读 |
| 最后修改者 | 文本 | 显示最后修改来源 | 只读 |
| 最后修改时间 | 日期时间 | 最后修改时间 | 只读 |
| 同步状态 | 单选 | 同步中/已同步/冲突 | 只读 |
| 数据来源 | 单选 | Web/飞书/API | 只读 |

### 4.2 飞书冲突提示

使用飞书的**条件格式**高亮冲突记录：

```javascript
// 飞书表格自动化规则
// 当 "同步状态" = "冲突" 时，整行标红
{
  "condition": {
    "field": "同步状态",
    "operator": "is",
    "value": ["冲突"]
  },
  "format": {
    "background_color": "#FEE2E2",
    "text_color": "#DC2626"
  }
}
```

---

## 5. 同步策略

### 5.1 实时同步（Web端）

```typescript
// WebSocket 或 Server-Sent Events 实时同步

// src/lib/services/sync.service.ts

export class SyncService {
  /**
   * 订阅任务更新
   */
  subscribeToTask(taskId: string, callback: (task: Task) => void) {
    const eventBus = getEventBus();

    return eventBus.on('task.updated', (data) => {
      if (data.taskId === taskId) {
        callback(data.task);
      }
    });
  }

  /**
   * 广播任务更新
   */
  broadcastTaskUpdate(task: Task) {
    const eventBus = getEventBus();
    eventBus.emit('task.updated', { task });
  }
}
```

### 5.2 定时同步（飞书端）

```typescript
// 飞书表格定时拉取最新状态

// src/lib/services/feishu-sync.service.ts

export class FeishuSyncService {
  /**
   * 定期同步飞书记录状态到数据库
   */
  async syncPendingTasks(): Promise<void> {
    const taskRepo = getTaskRepository();
    const feishuService = getFeishuService();

    // 查找所有进行中的任务
    const pendingTasks = await taskRepo.findMany({
      status: { in: ['PENDING', 'PROCESSING'] },
    });

    for (const task of pendingTasks) {
      if (!task.feishuRecordId) continue;

      try {
        const feishuRecord = await feishuService.getRecord(task.feishuRecordId);
        const feishuStatus = this.mapFeishuStatus(feishuRecord.fields['状态']);

        // 如果飞书记录更新时间更新
        if (feishuRecord.last_modified_time > task.lastModifiedAt.getTime()) {
          // 检查是否有冲突
          if (task.version > 0) {
            // 标记冲突
            await taskRepo.update(task.id, {
              conflictDetected: true,
            });

            // 通知用户
            eventBus.emit('task.conflict', { taskId: task.id });
          } else {
            // 自动同步
            await this.syncFromFeishu(task, feishuRecord);
          }
        }
      } catch (error) {
        console.error('同步失败:', error);
      }
    }
  }

  /**
   * 从飞书同步到数据库
   */
  private async syncFromFeishu(task: Task, feishuRecord: any): Promise<void> {
    const taskRepo = getTaskRepository();

    await taskRepo.updateWithVersion(
      task.id,
      {
        prompt: feishuRecord.fields['提示词'],
        status: this.mapFeishuStatus(feishuRecord.fields['状态']),
        lastModifiedBy: 'feishu',
      },
      task.version
    );
  }
}
```

---

## 6. API响应增强

### 6.1 返回版本信息

```typescript
// GET /api/tasks/:id

export async function GET(req: NextRequest, { params }: { params: { id: string } }) {
  const task = await taskRepo.findById(params.id);

  return NextResponse.json({
    ...task,
    _meta: {
      version: task.version,
      lastModifiedBy: task.lastModifiedBy,
      lastModifiedAt: task.lastModifiedAt,
      canEdit: !task.conflictDetected,
      conflictDetected: task.conflictDetected,
    },
  });
}
```

### 6.2 更新时传入版本

```typescript
// PATCH /api/tasks/:id

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  const body = await req.json();
  const { version, ...updates } = body;

  try {
    const updated = await taskRepo.updateWithVersion(
      params.id,
      updates,
      version
    );

    return NextResponse.json(updated);
  } catch (error) {
    if (error instanceof VersionConflictError) {
      return NextResponse.json(
        {
          error: 'Version conflict',
          conflict: error.conflict,
        },
        { status: 409 } // 409 Conflict
      );
    }
    throw error;
  }
}
```

---

## 7. 用户体验设计

### 7.1 前端多用户操作状态显示

```typescript
// 在任务卡片顶部显示

<div className="flex items-center gap-2 border-b pb-2">
  <Avatar className="h-6 w-6">
    <AvatarImage src={getModifierAvatar(task.lastModifiedBy)} />
    <AvatarFallback>{task.lastModifiedBy[0]}</AvatarFallback>
  </Avatar>

  <span className="text-sm text-muted-foreground">
    {task.lastModifiedBy === 'web' && '网页用户'}
    {task.lastModifiedBy === 'feishu' && '飞书用户'}
    {task.lastModifiedBy === 'api' && '系统自动'}
    正在编辑
  </span>

  <span className="text-xs text-muted-foreground">
    {formatDistanceToNow(task.lastModifiedAt, { addSuffix: true })}
  </span>
</div>
```

### 7.2 实时协作指示器

```typescript
// 显示其他用户正在编辑的任务

function ActiveUsersIndicator() {
  const [activeTasks, setActiveTasks] = useState<Task[]>([]);

  useEffect(() => {
    // 订阅所有正在编辑的任务
    const syncService = new SyncService();
    const unsubscribe = syncService.subscribeToActiveTasks((tasks) => {
      setActiveTasks(tasks.filter(t => t.lastModifiedBy !== 'web'));
    });

    return unsubscribe;
  }, []);

  if (activeTasks.length === 0) return null;

  return (
    <div className="fixed bottom-4 right-4">
      <Badge variant="secondary">
        <Users className="h-3 w-3 mr-1" />
        {activeTasks.length} 个任务正在被编辑
      </Badge>
    </div>
  );
}
```

---

## 8. 实施建议

### 阶段1：基础乐观锁（必须）
- 添加 version 字段
- 实现带版本检查的更新
- 返回版本冲突错误

### 阶段2：冲突检测UI（推荐）
- 冲突解决对话框
- 同步状态指示器
- 最后修改者显示

### 阶段3：实时同步（可选）
- WebSocket/Server-Sent Events
- 多用户编辑提示
- 实时数据同步

### 阶段4：飞书增强（可选）
- 飞书表格控制字段
- 条件格式高亮冲突
- 定时同步任务

---

## 总结

采用**乐观锁 + 最终一致性**方案：

| 特性 | 说明 |
|------|------|
| 冲突检测 | 版本号比对 |
| 冲突解决 | 用户手动选择或自动合并 |
| 数据一致性 | 最终一致性（允许短暂不一致） |
| 用户体验 | 冲突时提示，非阻塞主流程 |
| 飞书集成 | 控制字段 + 条件格式高亮 |
