# Superpowers 使用指南 - 开发者篇

## 目录

- [快速开始](#快速开始)
- [核心原则](#核心原则)
- [使用方式对比](#使用方式对比)
- [实战场景指南](#实战场景指南)
- [对话示例](#对话示例)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)

---

## 快速开始

### 一句话概括

> **您只需要描述"要做什么"，AI 会自动选择"怎么做"**

### 最简单的使用方式

```bash
# 就像和一个经验丰富的开发者对话
"构建失败了"
"添加个批量删除功能"
"这个 bug 修复不了"
"准备部署了"

# AI 会自动：
# 1. 识别您的需求类型
# 2. 选择最合适的技能
# 3. 执行完整的开发流程
# 4. 验证结果
```

---

## 核心原则

### 技能触发机制

| 触发方式 | 适用场景 | 您需要做的 |
|---------|---------|-----------|
| **AI 自动判断** | 99% 的情况 | 自然描述需求 |
| **明确指定技能** | 特殊偏好 | "使用 xxx 技能" |

### AI 如何自动选择技能

```
您的输入 → AI 分析意图 → 匹配技能 → 执行流程
   ↓
  "有个 bug"
    ↓
识别为：问题修复
    ↓
选择：systematic-debugging
    ↓
执行：Phase 1(根因) → Phase 2(模式) → Phase 3(假设) → Phase 4(修复)
```

---

## 使用方式对比

### 方式 1: 自然描述（推荐）⭐

```bash
# 您只需要说
"构建失败了，报类型错误"

# AI 自动执行
[识别: bug → 选择: systematic-debugging]
→ Phase 1: 分析错误
→ Phase 2: 找到模式
→ Phase 3: 提出修复
→ Phase 4: 验证成功
```

**优点**: 简单、快速、无需学习

---

### 方式 2: 明确指定技能

```bash
# 您明确要求
"用 systematic-debugging 分析这个错误"

# AI 直接执行
[直接使用 systematic-debugging]
→ 完整流程...
```

**适用**: 您已熟悉技能，有明确偏好

---

### 方式 3: 详细描述需求（不推荐）⚠️

```bash
# ❌ 不推荐
"请帮我分析错误，找到根本原因，对比工作代码，
 提出假设，最小化测试，然后修复，最后验证"

# 问题：您已经描述了流程，AI 只能执行
# 缺点：冗长、限制了 AI 的判断
```

---

## 实战场景指南

### 场景 1: Bug 修复

#### 您只需要说

```bash
# 最简单
"构建失败了"

# 稍详细
"有个类型错误，修复不了"

# 描述现象
"npm run build 报错，提示 string 不能赋值给枚举"
```

#### AI 自动执行

```
1. 识别为 bug 修复场景
2. 使用 systematic-debugging 技能
3. 执行完整的调试流程：
   ├─ Phase 1: 读取错误、检查变更
   ├─ Phase 2: 找到工作示例、对比差异
   ├─ Phase 3: 提出假设、最小化修复
   └─ Phase 4: 验证构建成功
```

#### 实际对话示例

```
您: "构建失败了"

AI: 我来使用 systematic-debugging 分析这个问题。

    Phase 1: 根本原因分析
    ┌─────────────────────────────────┐
    │ 错误位置: task.repository.ts:34 │
    │ 错误类型: Type 'string' is not  │
    │   assignable to 'PromptSource'  │
    └─────────────────────────────────┘

    Phase 2: 模式分析
    ┌─────────────────────────────────┐
    │ 找到工作示例:                    │
    │ - sync-log.repository.ts 使用  │
    │   Prisma.InputJsonValue         │
    │ - 需要类型断言                   │
    └─────────────────────────────────┘

    Phase 3: 修复方案
    ┌─────────────────────────────────┐
    │ 使用 Prisma.TaskUncheckedCreateInput │
    │ 类型断言包裹整个 data 对象       │
    └─────────────────────────────────┘

    [执行修复...]

    Phase 4: 验证
    ✓ npm run build 成功
```

---

### 场景 2: 新功能开发

#### 您只需要说

```bash
# 简单描述
"添加批量删除功能"

# 描述需求
"我想加个任务导出功能"

# 提出想法
"能不能加个 AI 优化提示词的功能？"
```

#### AI 自动执行

```
1. 识别为新功能开发
2. 使用 brainstorming 探索需求
3. 使用 writing-plans 生成方案
4. 使用 executing-plans 执行实现
```

#### 实际对话示例

```
您: "我想加个批量删除功能"

AI: 让我使用 brainstorming 探索一下这个需求。

    === 需求探索 ===

    1. 功能范围
       ├─ 删除范围：全部选中 / 筛选结果 / 手动选择
       ├─ 删除确认：单次确认 / 批量确认
       └─ 删除策略：仅本地 / 同步飞书

    2. 边界情况
       ├─ 飞书同步失败如何处理？
       ├─ 部分删除成功如何反馈？
       └─ 删除权限如何控制？

    3. 技术方案
       ├─ 前端：多选 UI + 确认对话框
       ├─ 后端：批量删除 API
       └─ 飞书：批量删除记录 API

    [继续使用 writing-plans 生成详细实现计划...]
```

---

### 场景 3: 准备部署

#### 您只需要说

```bash
# 简单
"准备部署了"

# 描述状态
"功能开发完了，要上线"

# 请求验证
"帮我检查一下能不能部署"
```

#### AI 自动执行

```
1. 识别为部署场景
2. 使用 verification-before-completion
3. 执行所有检查：
   ├─ 构建成功
   ├─ 代码格式化
   ├─ Lint 检查
   ├─ 清理调试代码
   └─ 环境变量验证
```

#### 实际对话示例

```
您: "准备部署了"

AI: 我来使用 verification-before-completion 验证部署准备情况。

    === 部署前检查 ===

    [1/5] 构建检查
    ✓ npm run build 成功

    [2/5] 代码格式化
    ✓ npm run format 完成

    [3/5] Lint 检查
    ✓ npm run lint 通过

    [4/5] 代码清理
    检查 console.log...
    ✓ 无遗留调试代码

    [5/5] 环境变量
    ✓ DATABASE_URL 已配置
    ✓ ACCESS_TOKEN 已配置
    ✓ N8N_WEBHOOK_URL 已配置

    === 验证结果 ===
    ✅ 所有检查通过，可以部署

    建议命令：
    - Vercel: vercel --prod
    - 脚本: ./deploy.sh
```

---

### 场景 4: 复杂问题分析

#### 您只需要说

```bash
# 描述问题
"飞书同步总是失败"

# 描述现象
"任务创建后不显示"

# 表达困惑
"代码看起来没问题，但就是不工作"
```

#### AI 自动执行

```
1. 识别为调试场景
2. 使用 systematic-debugging 深入分析
3. 检查多个层面：
   ├─ 代码逻辑
   ├─ API 调用
   ├─ 数据库状态
   └─ 外部服务
```

#### 实际对话示例

```
您: "飞书同步总是失败"

AI: 让我使用 systematic-debugging 系统化分析这个问题。

    Phase 1: 根本原因分析
    ┌────────────────────────────┐
    │ 检查层面：                   │
    ├─ 1. SyncLog 表查看错误记录  │
    ├─ 2. 飞书配置验证            │
    ├─ 3. 网络连接测试            │
    ├─ 4. API 权限检查            │
    └─ 5. 熔断器状态              │
    └────────────────────────────┘

    [执行诊断...]

    Phase 2: 发现根因
    ┌────────────────────────────┐
    │ 问题：熔断器已开启          │
    │ 原因：连续 5 次失败          │
    │ 触发：飞书 APP_ID 配置错误  │
    └────────────────────────────┘

    Phase 3: 修复方案
    1. 修正 FEISHU_APP_ID
    2. 重置熔断器
    3. 验证连接

    [执行修复并验证...]
```

---

## 对话示例

### 示例 1: 完整的开发流程

```
您: "我想加个任务导出功能"

AI: [使用 brainstorming]
    让我探索一下这个需求...

    1. 导出格式：CSV / Excel / JSON？
    2. 导出范围：全部 / 筛选结果 / 选中？
    3. 权限控制：谁可以导出？
    ...

    [使用 writing-plans]
    生成实现计划...

    文件结构：
    ├─ src/lib/exporters/
    │  ├─ csv-exporter.ts
    │  ├─ excel-exporter.ts
    │  └── json-exporter.ts
    ├─ src/app/api/tasks/export/route.ts
    └─ src/components/tasks/ExportButton.tsx

    [使用 executing-plans]
    开始实现...

    [使用 verification-before-completion]
    验证完成...

    ✅ 功能已完成并验证通过
```

---

### 示例 2: 快速 Bug 修复

```
您: "npm run build 报错了"

AI: [使用 systematic-debugging]
    分析中...

    错误：Type 'string' is not assignable to 'PromptSource'
    位置：task.repository.ts:34

    修复：添加类型断言
    验证：构建成功 ✅
```

---

### 示例 3: 多任务并行

```
您: "同时修复这 3 个文件的类型错误：
    fileA.ts, fileB.ts, fileC.ts"

AI: [使用 dispatching-parallel-agents]
    启动并行处理...

    代理 1: 处理 fileA.ts...
    代理 2: 处理 fileB.ts...
    代理 3: 处理 fileC.ts...

    [汇总结果]
    ✅ 全部修复完成
    ✓ fileA.ts: 添加类型断言
    ✓ fileB.ts: 修复枚举类型
    ✓ fileC.ts: 更新接口定义
```

---

## 最佳实践

### DO ✅

| 做法 | 示例 |
|-----|------|
| 用自然语言描述问题 | "构建失败了" |
| 简洁表达需求 | "添加批量删除" |
| 描述现象而非方案 | "任务创建后不显示" |
| 信任 AI 的判断 | 让 AI 选择技能 |
| 提供上下文 | "在迁移到新版本后，构建失败了" |

### DON'T ❌

| 做法 | 原因 |
|-----|------|
| 描述完整流程 | 限制 AI 的判断 |
| 指定技术实现细节 | AI 更懂最佳实践 |
| 过于简单或模糊 | "帮我看看" 缺少上下文 |
| 假设 AI 知道所有背景 | 提供必要的上下文信息 |

---

## 常见问题

### Q1: 我需要记住所有技能名称吗？

**A: 不需要！**

AI 会自动选择最合适的技能。您只需要：
- 描述问题或需求
- AI 自动识别场景
- AI 自动调用技能

只有当您有明确偏好时，才需要指定技能名称。

---

### Q2: 什么时候应该明确指定技能？

**A: 以下情况**

```bash
# 1. 您已熟悉技能，有明确偏好
"用 systematic-debugging 分析这个"

# 2. 想跳过某些步骤
"跳过 brainstorming，直接写计划"

# 3. 特殊需求
"用并行处理同时做这些任务"
```

---

### Q3: AI 会不会选错技能？

**A: 很少发生**

AI 的技能选择逻辑：
```
您的描述 → 关键词分析 → 场景匹配 → 技能选择

"bug" / "错误" / "失败" → systematic-debugging
"添加" / "新功能" / "实现" → brainstorming + writing-plans
"部署" / "上线" / "发布" → verification-before-completion
```

如果 AI 选择了不合适的技能，您可以直接说：
```bash
"这不是 bug，是新功能开发"
"切换到 brainstorming"
```

---

### Q4: 我需要学习每个技能的详细流程吗？

**A: 不需要！**

您只需要：
- ✅ 知道有哪些技能可用
- ✅ 了解每个技能解决什么类型的问题
- ❌ 不需要记住详细流程（AI 会执行）

**快速参考**：

| 技能 | 解决什么问题 | 触发关键词 |
|-----|------------|-----------|
| systematic-debugging | Bug、错误、故障 | bug, 错误, 失败, 不工作 |
| brainstorming | 新功能、需求探索 | 添加, 新功能, 实现, 功能 |
| writing-plans | 实现计划、设计方案 | 计划, 方案, 设计 |
| verification-before-completion | 部署前验证 | 部署, 上线, 发布, 检查 |
| requesting-code-review | 代码审查 | 审查, review, 检查代码 |

---

### Q5: 如何获得最佳效果？

**A: 提供适当的上下文**

```bash
# ❌ 太简单
"帮我看看"

# ✅ 适当上下文
"在迁移到 Prisma 后，构建失败了"

# ✅ 描述现象
"任务创建后，列表中看不到，但数据库里有"

# ✅ 描述期望
"我想添加一个功能，让用户可以批量删除任务"
```

---

## 快速参考卡片

### 🐛 Bug 修复

```
您说: "构建失败了" / "有个 bug" / "报错了"
AI 用: systematic-debugging
```

### ✨ 新功能开发

```
您说: "添加 xxx 功能" / "实现 xxx"
AI 用: brainstorming → writing-plans → executing-plans
```

### 🚀 准备部署

```
您说: "准备部署" / "要上线了"
AI 用: verification-before-completion
```

### 🔍 代码审查

```
您说: "帮我审查代码" / "检查这段代码"
AI 用: requesting-code-review
```

### 🔄 多任务并行

```
您说: "同时处理这几个" / "并行执行"
AI 用: dispatching-parallel-agents
```

---

## 总结

### 核心要点

1. **自然对话**：像和同事交流一样描述问题
2. **信任 AI**：让 AI 自动选择最合适的技能
3. **提供上下文**：适当的背景信息帮助 AI 理解
4. **明确意图**：有特殊需求时直接说明

### 记住这个

> **您专注于"要做什么"，AI 负责"怎么做"**

### 开始使用

现在就试试：
```bash
"帮我分析一下当前项目的构建状态"
```

或

```bash
"我想添加一个用户反馈功能"
```

看看 AI 如何自动选择和执行技能！
