# 双端并发场景遗漏分析与交互完善方案

## 一、并发冲突处理（人机交互关键点）

### 1.1 冲突发现与通知

**当前状态**：有冲突检测机制，但用户可能不知道

**缺失的交互**：

```
场景：前端用户A修改提示词的同时，飞书用户B也修改了

当前：
❌ 后端检测到冲突，但前端无提示
❌ 用户可能不知道自己的修改覆盖了对方

需要：
✅ 实时冲突提示
✅ 冲突解决对话框
✅ 双方数据对比显示
```

**解决方案**：

```typescript
// 冲突检测提示组件
interface ConflictDetectedAlertProps {
  taskId: string;
  conflict: {
    localChanges: Record<string, any>;
    remoteChanges: Record<string, any>;
    remoteModifier: string;
    conflictTime: Date;
  };
  onResolve: (strategy: 'use_local' | 'use_remote' | 'merge') => void;
}

export function ConflictDetectedAlert({ conflict, onResolve }: ConflictDetectedAlertPropsProps) {
  return (
    <Dialog open={true}>
      <DialogContent className="max-w-2xl">
        <DialogTitle>⚠️ 检测到数据冲突</DialogTitle>

        <Alert variant="destructive">
          <AlertTriangle className="h-4 w-4" />
          <AlertTitle>其他用户也在修改此任务</AlertTitle>
          <AlertDescription>
            {conflict.remoteModifier} 在 {formatDistanceToNow(conflict.conflictTime)}
            修改了以下字段，请选择处理方式
          </AlertDescription>
        </Alert>

        {/* 冲突字段列表 */}
        <div className="space-y-3">
          {Object.keys(conflict.localChanges).map(field => (
            <ConflictFieldComparison
              key={field}
              fieldName={field}
              localValue={conflict.localChanges[field]}
              remoteValue={conflict.remoteChanges[field]}
            />
          ))}
        </div>

        {/* 解决方案 */}
        <div className="flex gap-2">
          <Button onClick={() => onResolve('use_local')}>
            保留我的修改
          </Button>
          <Button onClick={() => onResolve('use_remote')} variant="outline">
            使用对方的修改
          </Button>
          <Button onClick={() => onResolve('merge')} variant="secondary">
            查看详情手动合并
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

### 1.2 冲突预防机制

**缺失的功能**：

```
✅ 实时显示"其他用户正在编辑"
✅ 编辑锁机制（可选）
✅ 自动保存草稿
```

```typescript
// 编辑状态指示器
function EditingStatus({ taskId }: { taskId: string }) {
  const [otherEditors, setOtherEditors] = useState<User[]>([]);

  useEffect(() => {
    // 订阅编辑状态
    const ws = getWebSocket();
    ws.subscribe(`task:${taskId}:editing`, (editors) => {
      // 过滤掉当前用户
      setOtherEditors(editors.filter(e => e.id !== currentUserId));
    });

    // 通知其他用户"我正在编辑"
    ws.emit('task:editing:start', { taskId, userId: currentUserId });

    return () => {
      ws.emit('task:editing:stop', { taskId, userId: currentUserId });
    };
  }, [taskId]);

  if (otherEditors.length === 0) return null;

  return (
    <Alert>
      <Users className="h-4 w-4" />
      <AlertDescription>
        {otherEditors.map(u => u.name).join(', ')} 正在编辑此任务
      </AlertDescription>
    </Alert>
  );
}
```

---

## 二、数据同步状态的可见性

### 2.1 同步进度提示

**当前状态**：用户不知道同步是否成功

**需要的交互**：

```
✅ 提交后显示"正在同步到飞书..."
✅ 同步成功后显示"✅ 已同步到飞书"
✅ 同步失败后显示"⚠️ 飞书同步失败，稍后重试"
```

```typescript
// 同步状态提示
function SyncStatusToast({ syncState }: { syncState: SyncState }) {
  useEffect(() => {
    if (syncState.status === 'syncing') {
      toast({
        title: '正在同步到飞书...',
        description: '请稍候',
        duration: Infinity,
      });
    }

    if (syncState.status === 'success') {
      toast({
        title: '✅ 已同步到飞书',
        description: '飞书用户可以看到此任务',
        duration: 3000,
      });
    }

    if (syncState.status === 'failed') {
      toast({
        title: '⚠️ 飞书同步失败',
        description: syncState.error,
        variant: 'destructive',
        action: <Button onClick={retry}>重试</Button>
      });
    }
  }, [syncState]);
}
```

### 2.2 飞书表格同步状态显示

**缺失的字段**：

```
飞书表格需要显示：
- 同步状态（已同步/同步中/失败）
- 最后同步时间
- 同步失败原因（如果失败）
```

---

## 三、数据一致性的用户确认

### 3.1 数据刷新提示

**场景**：用户在查看任务时，飞书有新数据

**需要的交互**：

```
✅ "检测到新数据，是否刷新？"
✅ 显示"自动刷新"开关
✅ 显示"最后更新时间"
```

```typescript
// 数据刷新提示
function DataUpdatePrompt({ taskId, hasNewData }: Props) {
  if (!hasNewData) return null;

  return (
    <Alert>
      <RefreshCw className="h-4 w-4" />
      <AlertTitle>检测到新数据</AlertTitle>
      <AlertDescription className="flex items-center gap-2">
        <span>飞书用户更新了此任务</span>
        <Button size="sm" onClick={refresh}>立即刷新</Button>
        <Button size="sm" variant="ghost" onClick={dismiss}>稍后</Button>
      </AlertDescription>
    </Alert>
  );
}
```

### 3.2 数据版本对比

**场景**：用户想查看修改历史

**需要的功能**：

```
✅ 显示任务修改历史
✅ 对比不同版本的数据
✅ 一键恢复到历史版本
```

```typescript
// 版本历史
function TaskVersionHistory({ taskId }: { taskId: string }) {
  const [versions, setVersions] = useState<TaskVersion[]>([]);

  return (
    <Dialog>
      <DialogContent className="max-w-4xl">
        <DialogTitle>任务修改历史</DialogTitle>

        <div className="space-y-2">
          {versions.map((version, index) => (
            <VersionItem
              key={version.id}
              version={version}
              isCurrent={index === 0}
              onRestore={() => restoreVersion(version.id)}
              onCompare={index < versions.length - 1
                ? () => compareVersions(version, versions[index + 1])
                : undefined
              }
            />
          ))}
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

---

## 四、错误处理和降级提示

### 4.1 飞书服务不可用

**场景**：飞书API故障

**需要的交互**：

```
✅ 明确提示"飞书服务暂时不可用"
✅ 说明"任务已保存，稍后自动同步"
✅ 提供"手动重试"按钮
```

```typescript
// 飞书服务降级提示
function FeishuDegradedAlert() {
  return (
    <Alert variant="warning">
      <CloudOff className="h-4 w-4" />
      <AlertTitle>飞书服务暂时不可用</AlertTitle>
      <AlertDescription className="space-y-2">
        <p>您的任务已保存，将在飞书服务恢复后自动同步</p>
        <Button size="sm" onClick={manualRetry}>立即重试</Button>
      </AlertDescription>
    </Alert>
  );
}
```

### 4.2 网络错误处理

**场景**：网络中断

**需要的交互**：

```
✅ 显示"网络连接已断开"
✅ 提供"离线模式"提示
✅ 网络恢复后自动重试
```

```typescript
// 网络状态监听
function NetworkStatusIndicator() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      toast.success('网络已连接，正在同步数据...');
      syncPendingData();
    };

    const handleOffline = () => {
      setIsOnline(false);
      toast.error('网络连接已断开，进入离线模式');
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  if (isOnline) return null;

  return (
    <Alert variant="destructive">
      <WifiOff className="h-4 w-4" />
      <AlertTitle>离线模式</AlertTitle>
      <AlertDescription>
        您的操作将保存在本地，网络恢复后自动同步
      </AlertDescription>
    </Alert>
  );
}
```

---

## 五、用户操作的撤销机制

### 5.1 操作确认

**场景**：用户删除任务

**需要的交互**：

```
✅ 二次确认对话框
✅ 显示"此操作将同步删除飞书记录"
✅ 提供"仅删除本地记录"选项
```

```typescript
// 删除确认对话框
function DeleteConfirmDialog({ task, onConfirm }: Props) {
  const [deleteScope, setDeleteScope] = useState<'both' | 'local'>('both');

  return (
    <Dialog>
      <DialogContent>
        <DialogTitle>确认删除任务？</DialogTitle>

        <div className="space-y-4">
          <Alert>
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>
              此操作无法撤销
            </AlertDescription>
          </Alert>

          <div className="space-y-2">
            <Label>删除范围</Label>
            <RadioGroup value={deleteScope} onValueChange={setDeleteScope}>
              <div className="flex items-center gap-2">
                <RadioGroupItem value="both" id="both" />
                <Label htmlFor="both">
                  同时删除本地和飞书记录
                </Label>
              </div>
              <div className="flex items-center gap-2">
                <RadioGroupItem value="local" id="local" />
                <Label htmlFor="local">
                  仅删除本地记录（保留飞书记录）
                </Label>
              </div>
            </RadioGroup>
          </div>

          <div className="flex gap-2">
            <Button onClick={onConfirm} variant="destructive">
              确认删除
            </Button>
            <Button variant="outline">
              取消
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

### 5.2 操作历史和撤销

**场景**：用户误操作

**需要的功能**：

```
✅ 操作历史记录
✅ 撤销上一次操作
✅ 重做已撤销的操作
```

```typescript
// 操作历史管理
class OperationHistory {
  private history: Operation[] = [];
  private currentIndex = -1;

  addOperation(operation: Operation) {
    // 删除当前指针之后的操作
    this.history = this.history.slice(0, this.currentIndex + 1);
    // 添加新操作
    this.history.push(operation);
    this.currentIndex++;
  }

  undo(): Operation | null {
    if (this.currentIndex < 0) return null;
    return this.history[this.currentIndex--];
  }

  redo(): Operation | null {
    if (this.currentIndex >= this.history.length - 1) return null;
    return this.history[++this.currentIndex];
  }
}
```

---

## 六、批量操作的交互

### 6.1 批量修改确认

**场景**：飞书用户批量修改多个任务的提示词

**需要的交互**：

```
✅ 显示"将修改 N 个任务"
✅ 列出要修改的任务
✅ 提供预览和确认
```

```typescript
// 批量操作预览
function BatchOperationPreview({
  tasks,
  operation
}: {
  tasks: Task[],
  operation: BatchOperation
}) {
  return (
    <Dialog>
      <DialogContent className="max-w-3xl">
        <DialogTitle>
          批量{operation.type}确认
        </DialogTitle>

        <div className="space-y-4">
          <Alert>
            <Info className="h-4 w-4" />
            <AlertDescription>
              将对 {tasks.length} 个任务执行{operation.type}操作
            </AlertDescription>
          </Alert>

          <div className="max-h-96 overflow-y-auto">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>任务ID</TableHead>
                  <TableHead>当前值</TableHead>
                  <TableHead>新值</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {tasks.map(task => (
                  <TableRow key={task.id}>
                    <TableCell>{task.id.slice(0, 8)}</TableCell>
                    <TableCell>{task.prompt}</TableCell>
                    <TableCell className="text-green-600">
                      {operation.newValue}
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>

          <div className="flex gap-2">
            <Button onClick={confirm}>确认修改</Button>
            <Button variant="outline" onClick={cancel}>取消</Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

### 6.2 批量操作进度

**场景**：批量操作进行中

**需要的交互**：

```
✅ 显示进度条
✅ 显示"已完成 X / 总数 Y"
✅ 显示失败的列表
```

```typescript
// 批量操作进度
function BatchOperationProgress({
  progress,
  results
}: {
  progress: { current: number; total: number },
  results: { success: number; failed: number; items: any[] }
}) {
  return (
    <Dialog open={true}>
      <DialogContent>
        <DialogTitle>批量操作进行中</DialogTitle>

        <div className="space-y-4">
          <Progress
            value={(progress.current / progress.total) * 100}
          />

          <div className="text-sm text-center">
            已完成 {progress.current} / {progress.total}
          </div>

          {results.failed > 0 && (
            <Alert variant="destructive">
              <AlertDescription>
                {results.failed} 个任务操作失败，
                <Button size="sm" variant="link">
                  查看详情
                </Button>
              </AlertDescription>
            </Alert>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

---

## 七、通知和消息中心

### 7.1 实时通知

**缺失的功能**：

```
✅ 任务完成通知
✅ 飞书用户修改通知
✅ 冲突检测通知
✅ 同步失败通知
```

```typescript
// 通知中心
function NotificationCenter() {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button variant="ghost" className="relative">
          <Bell className="h-5 w-5" />
          {unreadCount > 0 && (
            <Badge className="absolute -top-1 -right-1 h-5 w-5 rounded-full p-0 flex items-center justify-center">
              {unreadCount}
            </Badge>
          )}
        </Button>
      </PopoverTrigger>

      <PopoverContent className="w-80" align="end">
        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <h4 className="font-medium">通知</h4>
            <Button size="sm" variant="ghost" onClick={markAllRead}>
              全部已读
            </Button>
          </div>

          <div className="space-y-2">
            {notifications.map(notification => (
              <NotificationItem
                key={notification.id}
                notification={notification}
                onRead={() => markAsRead(notification.id)}
                onDismiss={() => dismiss(notification.id)}
              />
            ))}
          </div>

          {notifications.length === 0 && (
            <div className="text-center text-sm text-muted-foreground py-4">
              暂无新通知
            </div>
          )}
        </div>
      </PopoverContent>
    </Popover>
  );
}
```

### 7.2 通知类型定义

```typescript
interface Notification {
  id: string;
  type: 'task_completed' | 'conflict_detected' | 'sync_failed' | 'task_updated';
  title: string;
  message: string;
  taskId?: string;
  timestamp: Date;
  read: boolean;
  actions?: NotificationAction[];
}

interface NotificationAction {
  label: string;
  action: () => void;
  variant?: 'default' | 'destructive';
}
```

---

## 八、用户引导和帮助

### 8.1 新手引导

**场景**：用户第一次使用双端同步功能

**需要的交互**：

```
✅ 功能介绍引导
✅ 操作步骤说明
✅ 常见问题解答
```

```typescript
// 新手引导
function OnboardingGuide() {
  const [step, setStep] = useState(0);
  const [showGuide, setShowGuide] = useState(true);

  const steps = [
    {
      title: '欢迎使用AI服装平台',
      content: '您的任务会自动同步到飞书多维表格',
      position: 'center',
    },
    {
      title: '创建任务',
      content: '上传图片并输入提示词，点击生成',
      position: 'right',
      target: '#create-task',
    },
    {
      title: '查看同步状态',
      content: '任务卡片显示同步状态',
      position: 'left',
      target: '#sync-status',
    },
    {
      title: '处理冲突',
      content: '如果其他用户也在编辑，系统会提示您',
      position: 'bottom',
      target: '#conflict-alert',
    },
  ];

  return (
    <Dialog open={showGuide} onOpenChange={setShowGuide}>
      <DialogContent>
        <DialogTitle>{steps[step].title}</DialogTitle>
        <div className="space-y-4">
          <p>{steps[step].content}</p>

          <div className="flex justify-between">
            <Button
              variant="ghost"
              onClick={() => setStep(Math.max(0, step - 1))}
              disabled={step === 0}
            >
              上一步
            </Button>

            <div className="flex gap-1">
              {steps.map((_, i) => (
                <div
                  key={i}
                  className={cn(
                    "w-2 h-2 rounded-full",
                    i === step ? "bg-primary" : "bg-muted"
                  )}
                />
              ))}
            </div>

            <Button
              onClick={() => {
                if (step < steps.length - 1) {
                  setStep(step + 1);
                } else {
                  setShowGuide(false);
                }
              }}
            >
              {step < steps.length - 1 ? '下一步' : '完成'}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

### 8.2 上下文帮助

**场景**：用户在操作时遇到疑问

**需要的交互**：

```
✅ 每个字段的问号帮助图标
✅ 悬停显示说明
✅ 链接到详细文档
```

```typescript
// 上下文帮助提示
function ContextualHelp({ topic, children }: { topic: string; children?: ReactNode }) {
  return (
    <Tooltip>
      <TooltipTrigger asChild>
        <Button variant="ghost" size="icon" className="h-4 w-4">
          <CircleHelp className="h-3 w-3" />
        </Button>
      </TooltipTrigger>
      <TooltipContent side="right" className="max-w-xs">
        <HelpContent topic={topic} />
      </TooltipContent>
    </Tooltip>
  );
}
```

---

## 九、数据安全和权限

### 9.1 权限提示

**场景**：用户尝试无权操作

**需要的交互**：

```
✅ 明确提示"您没有权限执行此操作"
✅ 说明"请联系管理员"
✅ 提供其他可用操作
```

```typescript
// 权限错误提示
function PermissionError({ operation, resource }: Props) {
  return (
    <Alert variant="destructive">
      <ShieldAlert className="h-4 w-4" />
      <AlertTitle>权限不足</AlertTitle>
      <AlertDescription>
        您没有权限{operation}{resource}，
        请联系管理员或使用其他可用操作。
      </AlertDescription>
    </Alert>
  );
}
```

### 9.2 敏感操作二次确认

**场景**：删除、批量修改等敏感操作

**需要的交互**：

```
✅ 输入密码确认
✅ 输入"确认"文字确认
✅ 发送验证码确认
```

```typescript
// 敏感操作确认
function SensitiveOperationConfirm({
  operation,
  onConfirm
}: {
  operation: string;
  onConfirm: () => void;
}) {
  const [confirmText, setConfirmText] = useState('');

  return (
    <Dialog>
      <DialogContent>
        <DialogTitle>敏感操作确认</DialogTitle>

        <div className="space-y-4">
          <Alert variant="destructive">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>
              您正在执行：{operation}
            </AlertDescription>
          </Alert>

          <div>
            <Label>输入"确认"以继续</Label>
            <Input
              value={confirmText}
              onChange={(e) => setConfirmText(e.target.value)}
              placeholder="请输入"确认""
            />
          </div>

          <Button
            onClick={onConfirm}
            disabled={confirmText !== '确认'}
            variant="destructive"
            className="w-full"
          >
            确认执行
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

---

## 十、性能优化反馈

### 10.1 加载状态

**场景**：数据加载、同步进行中

**需要的交互**：

```
✅ 骨架屏加载占位
✅ 进度条显示
✅ 预计剩余时间
```

```typescript
// 骨架屏
function TaskCardSkeleton() {
  return (
    <Card>
      <CardHeader>
        <Skeleton className="h-5 w-3/4" />
        <Skeleton className="h-4 w-1/2" />
      </CardHeader>
      <CardContent>
        <Skeleton className="h-20 w-full" />
      </CardContent>
    </Card>
  );
}
```

### 10.2 操作反馈

**场景**：用户操作后的即时反馈

**需要的交互**：

```
✅ 按钮加载状态
✅ 操作成功动画
✅ 失败震动反馈
```

```typescript
// 加载状态按钮
function ButtonWithLoading({
  loading,
  children,
  ...props
}: ButtonProps & { loading?: boolean }) {
  return (
    <Button {...props} disabled={loading || props.disabled}>
      {loading ? (
        <>
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          处理中...
        </>
      ) : (
        children
      )}
    </Button>
  );
}
```

---

## 十一、移动端适配

### 11.1 响应式布局

**场景**：用户在手机上访问

**需要的交互**：

```
✅ 移动端优化的布局
✅ 触摸友好的交互
✅ 移动端通知
```

### 11.2 PWA支持

**场景**：用户离线使用

**需要的交互**：

```
✅ 离线可用
✅ 后台同步
✅ 推送通知
```

---

## 总结：优先级排序

### 高优先级（必须实现）

1. ✅ 冲突检测和解决对话框
2. ✅ 同步状态提示（成功/失败/进行中）
3. ✅ 操作确认对话框（删除、批量操作）
4. ✅ 错误提示和降级说明
5. ✅ 实时编辑状态显示

### 中优先级（推荐实现）

6. ✅ 操作历史和撤销
7. ✅ 通知中心
8. ✅ 数据刷新提示
9. ✅ 批量操作进度
10. ✅ 新手引导

### 低优先级（可选）

11. ⭕ 版本历史对比
12. ⭕ 上下文帮助
13. ⭕ 移动端优化
14. ⭕ PWA支持

---

## 实施建议

### 第一阶段：核心交互

- 冲突解决对话框
- 同步状态提示
- 操作确认

### 第二阶段：增强体验

- 通知中心
- 操作历史
- 实时编辑状态

### 第三阶段：完善细节

- 新手引导
- 帮助文档
- 移动端优化
